name: Ansible EE Image

on:
  workflow_call:
    inputs:
      release:
        description: Prepare EE for a release
        type: boolean
        default: false
      release_tag:              # tag starting with 'v' like v1.2.3
        description: Git tag for release to prepare EE
        type: string
        required: false
  workflow_dispatch:
    inputs:
      release:
        description: EE for a release or development
        type: boolean
        default: false

env:
  NAMESPACE: paloaltonetworks
  COLLECTION_NAME: panos
  PYTHON_VERSION: 3.9           # TODO do we need this, as we take it from pyproject.yml ?

jobs:

  build_ee:
    name: Ansible EE
    runs-on: ubuntu-latest

    permissions:
      contents: read
      packages: write

    # defaults:
    #   run:
    #     working-directory: ansible_collections/${{ env.NAMESPACE }}/${{ env.COLLECTION_NAME }}

    steps:
      # if event == workflow_call and inputs.release == true
      #   release_tag must be given as input
      #   checkout tag and prepare EE on tag
      # elif event == workflow_call and inputs.release == false
      #   normal checkout - it will checkout whatever the workflow is run on
      #   prepare EE on branch
      # elif event == workflow_dispatch and inputs.release == true
      #   workflow must be run on a tag
      #   checkout tag and prepare EE on tag
      # elif event == workflow_dispatch and inputs.release == false
      #   normal checkout - it will checkout whatever the workflow is run on
      #   prepare EE on branch

      # TODO workflow_call is triggered by push and PR - need to check PR as well..
      - name: check and findout the tag
        id: tag
        # outputs tag name as v1.2.3 and version as 1.2.3
        run: |
          if [[ "${{ github.event_name }}" == "push" &&
                "${{ inputs.release }}" == "true" ]]; then
              if [[ "${{ inputs.release_tag }}" != "v"* ]]; then
                  echo "release_tag (${{ inputs.release_tag }}) must be provided when workflow_call called with release."
                  exit 1
              fi
              TAG_VERSION=$(echo "${{inputs.release_tag}}" | sed 's#v##')
              echo "name=${{inputs.release_tag}}" >> $GITHUB_OUTPUT
              echo "version=$TAG_VERSION" >> $GITHUB_OUTPUT
              echo "Ansible EE will be prepared for release ${{ inputs.release_tag }}"
          elif [[ "${{ github.event_name }}" == "push" ]]; then
              echo "Ansible EE will be prepared for branch ${GITHUB_REF#refs/heads/}"
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" &&
                "${{ inputs.release }}" == "true" ]]; then
              if [[ "${GITHUB_REF}" != "refs/tags/v"* ]]; then
                  echo "workflow_dispatch must be run on a release tag when release is selected - run on ${GITHUB_REF}"
                  exit 1
              fi
              TAG_NAME=$(echo "${GITHUB_REF}" | sed 's#refs/tags/##')
              TAG_VERSION=$(echo "${TAG_NAME}" | sed 's#v##')
              echo "name=$TAG_NAME" >> $GITHUB_OUTPUT
              echo "version=$TAG_VERSION" >> $GITHUB_OUTPUT
              echo "Ansible EE will be prepared for release $TAG_NAME"
          else
              echo "Ansible EE will be prepared for branch ${GITHUB_REF#refs/heads/}"
          fi
          # if [[ "${{ github.ref }}" == "refs/tags/"* ]]; then
          #   echo "This workflow is run on tag: ${{ github.ref }}"
          #   TAG_NAME=$(echo "${{ github.ref }}" | sed 's#refs/tags/##')
          #   echo "name=$TAG_NAME" >> $GITHUB_OUTPUT
          #   echo "Tag: $TAG_NAME"
          # else
          #   echo "This workflow is not run on a tag"
          #   exit 1
          # fi
        env:
          GITHUB_REF: ${{ github.ref }}
        # working-directory: .

      # TODO CHECKOUT tag.outputs.name BUT IS IT POSSIBLE TO OMIT TAG WHEN IT'S EMPTY?
      # so we can checkout the branch itself when tag is empty
      - name: check out code
        uses: actions/checkout@v4
        with:
          # if tag is empty; github.ref else tag.outputs.name
          ref: ${{ steps.tag.outputs.name == '' && github.ref || steps.tag.outputs.name }}
          # path: ./ansible_collections/${{ env.NAMESPACE }}/${{ env.COLLECTION_NAME }}

      - name: discover Python version
        id: pyversion
        shell: bash
        run: |
          PYVER=$(grep '^[Pp]ython ' pyproject.toml | sed -E 's/python += +\"\^?([0-9]\.[0-9]+)(\.[0-9]+)?\"/\1/; /python/q1')
          echo "pyversion=$PYVER" >> $GITHUB_OUTPUT
        # uses: PaloAltoNetworks/pan-os-upgrade-assurance/.github/actions/discover_python_version@v0.3.1
        # working-directory doesn't work with uses, until you get a `with path` similar to checkout, this is going to be inline

      - name: install Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ steps.pyversion.outputs.pyversion }}
          cache: pip

      - name: install Poetry
        uses: Gr1N/setup-poetry@v8

      - name: prep Poetry venv
        run: |
          poetry env use ${{ steps.pyversion.outputs.pyversion }}
          poetry lock
          poetry install --with ansible-ee --without dev --no-root

      - name: set up Docker Buildx
        uses: docker/setup-buildx-action@v3

        # TODO version wrong in pyproject.toml
        # this DOES NOT start with v
      # - name: get version for release image
      #   id: tag
      #   run: echo "version_tag=$(poetry version -s)" >> $GITHUB_OUTPUT
      #   if: inputs.release

      # TODO release from checkout tag to exclude main label - DID NOT WORK
      # TRY with git context but need to restest develop - git folder not found in sub dir..
      # context workflow yapsan release icin label main oluyor.. X
      # context git yapsan develop icin fail ediyor, git folder bulamiyor cunku alt dizinde.
      # TODO BURADA KALDIN - checkout u direk ana dizine yapsak olmaz mi? ansible builder mi fail ediyor??
      - name: determine docker tags and labels
        id: meta
        uses: docker/metadata-action@v5
        with:
          context: git # git - this ensures to reference the current git context instead of workflow context (context info ref/sha)
          images: ghcr.io/alperenkose/pan-os-ansible # TODO ghcr.io/paloaltonetworks/pan-os-ansible
          tags: |
            type=semver,pattern=v{{version}}
            type=semver,pattern=v{{major}}.{{minor}}
            type=semver,pattern=v{{major}}
            type=ref,event=branch
            type=ref,event=tag

      # # TODO latest should only be tagged for release versions
      # - name: determine docker tags and labels for release image
      #   id: meta
      #   uses: docker/metadata-action@v5
      #   with:
      #     context: workflow # git - this ensures to reference the current git context instead of workflow context (context info ref/sha)
      #     images: ghcr.io/alperenkose/pan-os-ansible # TODO ghcr.io/paloaltonetworks/pan-os-ansible
      #     tags: |
      #       type=semver,pattern=v{{version}},value=${{ steps.tag.outputs.version_tag }}
      #       type=semver,pattern=v{{major}}.{{minor}},value=${{ steps.tag.outputs.version_tag }}
      #       type=semver,pattern=v{{major}},value=${{ steps.tag.outputs.version_tag }}
      #   if: inputs.release

        # NOTE we should take pan-os-ansible from galaxy for a release, but local build for develop
        # ref - https://github.com/ansible-collections/community.dns/blob/main/.github/workflows/ee.yml#L96-L98
      - name: Build collection from development branch
        run: |
          ansible-galaxy collection build
          # ansible-galaxy collection build --output-path ../../../
        if: ${{ inputs.release == false }}

      - name: create base EE file
        run: |
          cat > execution-environment.yml <<EOF
          ---
          version: 3

          images:
            base_image:
              name: quay.io/centos/centos:stream9

          dependencies:
            python_interpreter:
              package_system: python3.9
              python_path: /usr/bin/python3.9
            ansible_core:
              package_pip: ansible-core>=2.15.0rc2,<2.16
            ansible_runner:
              package_pip: ansible-runner
            system: |
              git-core [platform:rpm]
              python3.9-devel [platform:rpm compile]
              libcurl-devel [platform:rpm compile]
              sshpass [platform:rpm]
              rsync [platform:rpm]
              epel-release [platform:rpm]
              unzip [platform:rpm]
            galaxy: requirements.yml
            python: requirements-ee.txt

          additional_build_steps:
            append_base:
              - RUN \$PYCMD -m pip install -U pip
            prepend_builder:
              - COPY _build/src/requirements.txt src/requirements.txt
            append_final:
              # SymLink `python` -> `python3.9`
              - RUN alternatives --install /usr/bin/python python /usr/bin/python3.9 39

          EOF
        # working-directory: .

      - name: append build files to EE file for development
        run: |
          COLLECTION_FILENAME="$(ls "${{ env.NAMESPACE }}-${{ env.COLLECTION_NAME }}"-*.tar.gz)"
          # COLLECTION_PIP_REQUIREMENTS="ansible_collections/${{ env.NAMESPACE }}/${{ env.COLLECTION_NAME }}/requirements.txt"
          COLLECTION_PIP_REQUIREMENTS="requirements.txt"

          # append to existing EE file
          cat >> execution-environment.yml <<EOF
          additional_build_files:
            - src: ${COLLECTION_FILENAME}
              dest: src
            - src: ${COLLECTION_PIP_REQUIREMENTS}
              dest: src
          EOF
          echo "::group::execution-environment.yml"
          cat execution-environment.yml
          echo "::endgroup::"

          cat > requirements.yml <<EOF
          ---
          collections:
            - name: src/${COLLECTION_FILENAME}
              type: file
            - name: awx.awx
            - community.general
          EOF
          echo "::group::requirements.yml"
          cat requirements.yml
          echo "::endgroup::"
        if: ${{ inputs.release == false }}
        # working-directory: .

      - name: append build files to EE file for release
        run: |
          # COLLECTION_PIP_REQUIREMENTS="ansible_collections/${{ env.NAMESPACE }}/${{ env.COLLECTION_NAME }}/requirements.txt"
          COLLECTION_PIP_REQUIREMENTS="requirements.txt"

          # append to existing EE file
          cat >> execution-environment.yml <<EOF
          additional_build_files:
            - src: ${COLLECTION_PIP_REQUIREMENTS}
              dest: src
          EOF
          echo "::group::execution-environment.yml"
          cat execution-environment.yml
          echo "::endgroup::"

          # Collection Requirements
          cat > requirements.yml <<EOF
          ---
          collections:
            - name: paloaltonetworks.panos
              version: 2.21.2
              # version: ${{steps.tag.outputs.version}} TEMP commented for testing..
            - name: awx.awx
            - community.general
          EOF
          echo "::group::requirements.yml"
          cat requirements.yml
          echo "::endgroup::"
        if: inputs.release
        # working-directory: .

      - name: create requirements.txt
        run: |
          # Python Requirements
          cat > requirements-ee.txt <<EOF
          -r src/requirements.txt
          jmespath
          EOF
          echo "::group::requirements-ee.txt"
          cat requirements-ee.txt
          echo "::endgroup::"
        # working-directory: .

      # - name: Create files for building execution environment
      #   run: |
      #     COLLECTION_FILENAME="$(ls "${{ env.NAMESPACE }}-${{ env.COLLECTION_NAME }}"-*.tar.gz)"
      #     COLLECTION_PIP_REQUIREMENTS="ansible_collections/${{ env.NAMESPACE }}/${{ env.COLLECTION_NAME }}/requirements.txt"

      #     # EE config
      #     cat > execution-environment.yml <<EOF
      #     ---
      #     version: 3

      #     images:
      #       base_image:
      #         name: quay.io/centos/centos:stream9

      #     dependencies:
      #       python_interpreter:
      #         package_system: python3.9
      #         python_path: /usr/bin/python3.9
      #       ansible_core:
      #         package_pip: ansible-core>=2.15.0rc2,<2.16
      #       ansible_runner:
      #         package_pip: ansible-runner
      #       system: |
      #         git-core [platform:rpm]
      #         python3.9-devel [platform:rpm compile]
      #         libcurl-devel [platform:rpm compile]
      #         sshpass [platform:rpm]
      #         rsync [platform:rpm]
      #         epel-release [platform:rpm]
      #         unzip [platform:rpm]
      #       galaxy: requirements.yml
      #       python: requirements.txt

      #     additional_build_files:
      #       - src: ${COLLECTION_FILENAME}
      #         dest: src
      #       - src: ${COLLECTION_PIP_REQUIREMENTS}
      #         dest: src

      #     additional_build_steps:
      #       append_base:
      #         - RUN \$PYCMD -m pip install -U pip
      #       prepend_builder:
      #         - COPY _build/src/requirements.txt src/requirements.txt
      #       append_final:
      #         # SymLink `python` -> `python3.9`
      #         - RUN alternatives --install /usr/bin/python python /usr/bin/python3.9 39
      #     EOF
      #     echo "::group::execution-environment.yml"
      #     cat execution-environment.yml
      #     echo "::endgroup::"

      #     # Collection Requirements
      #     cat > requirements.yml <<EOF
      #     ---
      #     collections:
      #       - name: src/${COLLECTION_FILENAME}
      #         type: file
      #       - name: awx.awx
      #       - community.general
      #     EOF
      #     echo "::group::requirements.yml"
      #     cat requirements.yml
      #     echo "::endgroup::"

      #     # Python Requirements
      #     cat > requirements.txt <<EOF
      #     -r src/requirements.txt
      #     jmespath
      #     EOF
      #     echo "::group::requirements.txt"
      #     cat requirements.txt
      #     echo "::endgroup::"
      #   working-directory: .

      - name: create execution env context
        run: |
          poetry run -C ansible_collections/${{ env.NAMESPACE }}/${{ env.COLLECTION_NAME }} ansible-builder create -v 3 --output-filename Dockerfile
          ls -l ./context/
          ls -l ./context/_build/src/
          cat ./context/_build/src/requirements.txt
          cat ./context/Dockerfile
        # working-directory: .

      - name: login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: build and publish
        uses: docker/build-push-action@v5
        with:
          context: "./context/"
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          provenance: ${{ inputs.release }} # disable for development to keep number of images low

  # build_release_ee:
  #   name: Release Ansible EE
  #   runs-on: ubuntu-latest
  #   if: inputs.release
  #   # if: github.event_name == 'release' && github.event.action == 'published'
  #   # NOTE what if we make a release from develop branch? dont worry it would make both develop and alpha images I suppose..:)

  #   permissions:
  #     contents: read
  #     packages: write

  #   defaults:
  #     run:
  #       working-directory: ansible_collections/${{ env.NAMESPACE }}/${{ env.COLLECTION_NAME }}

  #   steps:

  #     # - name: Proceed if release job from CI workflow succeeded
  #     #   run: |
  #     #     curl -L \
  #     #       -H "Accept: application/vnd.github+json" \
  #     #       -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
  #     #       -H "X-GitHub-Api-Version: 2022-11-28" \
  #     #       ${{ github.event.workflow_run.jobs_url }} > jobs.json
  #     #     conclusion=$(jq < jobs.json --raw-output '.jobs[] | select( .name == "release" ) | .conclusion')
  #     #     echo ${conclusion}
  #     #     [[ ${conclusion} == "success" ]]
  #     #   working-directory: .

  #     - name: check out code
  #       uses: actions/checkout@v4
  #       with:
  #         path: ./ansible_collections/${{ env.NAMESPACE }}/${{ env.COLLECTION_NAME }}

  #     - name: discover Python version
  #       id: pyversion
  #       shell: bash
  #       run: |
  #         PYVER=$(grep '^[Pp]ython ' pyproject.toml | sed -E 's/python += +\"\^?([0-9]\.[0-9]+)(\.[0-9]+)?\"/\1/; /python/q1')
  #         echo "pyversion=$PYVER" >> $GITHUB_OUTPUT
  #       # uses: PaloAltoNetworks/pan-os-upgrade-assurance/.github/actions/discover_python_version@v0.3.1
  #       # working-directory doesn't work with uses, until you get a `with path` similar to checkout this is going to be inline

  #     - name: install Python
  #       uses: actions/setup-python@v4
  #       with:
  #         python-version: ${{ steps.pyversion.outputs.pyversion }}
  #         cache: pip

  #     - name: install Poetry
  #       uses: Gr1N/setup-poetry@v8

  #     - name: prep Poetry venv
  #       run: |
  #         poetry env use ${{ steps.pyversion.outputs.pyversion }}
  #         poetry lock
  #         poetry install --with ansible-ee --without dev --no-root

  #     - name: set up Docker Buildx
  #       uses: docker/setup-buildx-action@v3

  #     - name: get version for release image
  #       id: tag
  #       run: echo "version_tag=$(poetry version -s)" >> $GITHUB_OUTPUT

  #     # TODO latest should only be tagged for release versions
  #     - name: determine docker tags and labels for release image
  #       id: meta
  #       uses: docker/metadata-action@v5
  #       with:
  #         context: workflow # git - this ensures to reference the current git context instead of workflow context (context info ref/sha)
  #         images: ghcr.io/alperenkose/pan-os-ansible # TODO ghcr.io/paloaltonetworks/pan-os-ansible
  #         tags: |
  #           type=semver,pattern=v{{version}},value=${{ steps.tag.outputs.version_tag }}
  #           type=semver,pattern=v{{major}}.{{minor}},value=${{ steps.tag.outputs.version_tag }}
  #           type=semver,pattern=v{{major}},value=${{ steps.tag.outputs.version_tag }}

  #     - name: Create files for building execution environment
  #       run: |
  #         COLLECTION_PIP_REQUIREMENTS="ansible_collections/${{ env.NAMESPACE }}/${{ env.COLLECTION_NAME }}/requirements.txt"

  #         # EE config
  #         cat > execution-environment.yml <<EOF
  #         ---
  #         version: 3

  #         images:
  #           base_image:
  #             name: quay.io/centos/centos:stream9

  #         dependencies:
  #           python_interpreter:
  #             package_system: python3.9
  #             python_path: /usr/bin/python3.9
  #           ansible_core:
  #             package_pip: ansible-core>=2.15.0rc2,<2.16
  #           ansible_runner:
  #             package_pip: ansible-runner
  #           system: |
  #             git-core [platform:rpm]
  #             python3.9-devel [platform:rpm compile]
  #             libcurl-devel [platform:rpm compile]
  #             sshpass [platform:rpm]
  #             rsync [platform:rpm]
  #             epel-release [platform:rpm]
  #             unzip [platform:rpm]
  #           galaxy: requirements.yml
  #           python: requirements.txt

  #         additional_build_files:
  #           - src: ${COLLECTION_PIP_REQUIREMENTS}
  #             dest: src

  #         additional_build_steps:
  #           append_base:
  #             - RUN \$PYCMD -m pip install -U pip
  #           prepend_builder:
  #             - COPY _build/src/requirements.txt src/requirements.txt
  #           append_final:
  #             # SymLink `python` -> `python3.9`
  #             - RUN alternatives --install /usr/bin/python python /usr/bin/python3.9 39
  #         EOF
  #         echo "::group::execution-environment.yml"
  #         cat execution-environment.yml
  #         echo "::endgroup::"

  #         # Collection Requirements
  #         cat > requirements.yml <<EOF
  #         ---
  #         collections:
  #           - name: paloaltonetworks.panos
  #             version: ${{steps.tag.outputs.version_tag}}
  #           - name: awx.awx
  #           - community.general
  #         EOF
  #         echo "::group::requirements.yml"
  #         cat requirements.yml
  #         echo "::endgroup::"

  #         # Python Requirements
  #         cat > requirements.txt <<EOF
  #         -r src/requirements.txt
  #         jmespath
  #         EOF
  #         echo "::group::requirements.txt"
  #         cat requirements.txt
  #         echo "::endgroup::"
  #       working-directory: .

  #     - name: create execution env context
  #       run: |
  #         poetry run -C ansible_collections/${{ env.NAMESPACE }}/${{ env.COLLECTION_NAME }} ansible-builder create -v 3 --output-filename Dockerfile
  #         ls -l ./context/
  #         ls -l ./context/_build/src/
  #         cat ./context/_build/src/requirements.txt
  #         cat ./context/Dockerfile
  #       working-directory: .

  #     - name: login to GHCR
  #       uses: docker/login-action@v3
  #       with:
  #         registry: ghcr.io
  #         username: ${{ github.actor }}
  #         password: ${{ secrets.GITHUB_TOKEN }}

  #     - name: build and publish
  #       uses: docker/build-push-action@v5
  #       with:
  #         context: "./context/"
  #         push: true
  #         tags: ${{ steps.meta.outputs.tags }}
  #         labels: ${{ steps.meta.outputs.labels }}
  #         cache-from: type=gha
  #         cache-to: type=gha,mode=max
