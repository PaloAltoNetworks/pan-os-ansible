name: Ansible EE Image

on:
  workflow_call:
    inputs:
      release:
        description: EE for a release or development
        type: boolean
        default: false
  workflow_dispatch:
    inputs:
      release:
        description: EE for a release or development
        type: boolean
        default: false
  # push:
  #   branches:
  #     - develop
  #   tags:
  #     - 'v*'
  # release:
  #   types: [published]
  # workflow_run:                 # NOTE workflow runs from default branch..
  #   workflows: ['CI']
  #   types: completed

env:
  NAMESPACE: paloaltonetworks
  COLLECTION_NAME: panos
  PYTHON_VERSION: 3.9           # TODO do we need this, as we take it from pyproject.yml ?


  # one job can run on push to develop branch or on manual workflow_dispatch ?
  # and other job can run on release published (hoping release happens after being published to galaxy..)

jobs:

  build_dev_ee:
    name: Development Ansible EE
    runs-on: ubuntu-latest
    if: inputs.release == 'false'
    # needs: rc
    # if: needs.rc.outputs.rc == 'true'

    permissions:
      contents: read
      packages: write

    defaults:
      run:
        working-directory: ansible_collections/${{ env.NAMESPACE }}/${{ env.COLLECTION_NAME }}

    steps:
      # - name: debug github event
      #   id: tag
      #   run: |
      #     echo "github event: ${{ github.event }}"
      #     echo "github event workflow_run: ${{github.event.workflow_run}}"
      #     echo "github event workflow_run head: ${{github.event.workflow_run.head_branch}}"
      #     exit 1

      - name: check out code
        uses: actions/checkout@v4
        with:
          path: ./ansible_collections/${{ env.NAMESPACE }}/${{ env.COLLECTION_NAME }}

      - name: discover Python version
        id: pyversion
        shell: bash
        run: |
          PYVER=$(grep '^[Pp]ython ' pyproject.toml | sed -E 's/python += +\"\^?([0-9]\.[0-9]+)(\.[0-9]+)?\"/\1/; /python/q1')
          echo "pyversion=$PYVER" >> $GITHUB_OUTPUT
        # uses: PaloAltoNetworks/pan-os-upgrade-assurance/.github/actions/discover_python_version@v0.3.1
        # working-directory doesn't work with uses, until you get a `with path` similar to checkout this is going to be inline

      - name: install Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ steps.pyversion.outputs.pyversion }}
          cache: pip

      - name: install Poetry
        uses: Gr1N/setup-poetry@v8

      - name: prep Poetry venv
        run: |
          poetry env use ${{ steps.pyversion.outputs.pyversion }}
          poetry lock
          poetry install --with ansible-ee --without dev --no-root
        # working-directory: ansible_collections/${{ env.NAMESPACE }}/${{ env.COLLECTION_NAME }}

      - name: set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: determine docker tags and labels for development image
        id: meta
        uses: docker/metadata-action@v5
        with:
          context: workflow # git - this ensures to reference the current git context instead of workflow context (context info ref/sha)
          images: ghcr.io/alperenkose/pan-os-ansible # TODO ghcr.io/paloaltonetworks/pan-os-ansible
          tags: |
            type=ref,event=branch
            type=ref,event=tag

        # TODO we should take pan-os-ansible from galaxy for a release BUT what about develop branch??
        # https://github.com/ansible-collections/community.dns/blob/main/.github/workflows/ee.yml#L96-L98
        # TRY OUT dynamically creating EE. Or we can make dynamic for develop and use static file for release?
      - name: Build collection from development branch
        run: |
          ansible-galaxy collection build --output-path ../../../

      - name: Create files for building execution environment
        run: |
          COLLECTION_FILENAME="$(ls "${{ env.NAMESPACE }}-${{ env.COLLECTION_NAME }}"-*.tar.gz)"
          COLLECTION_PIP_REQUIREMENTS="ansible_collections/${{ env.NAMESPACE }}/${{ env.COLLECTION_NAME }}/requirements.txt"

          # EE config
          cat > execution-environment.yml <<EOF
          ---
          version: 3

          images:
            base_image:
              name: quay.io/centos/centos:stream9

          dependencies:
            python_interpreter:
              package_system: python3.9
              python_path: /usr/bin/python3.9
            ansible_core:
              package_pip: ansible-core>=2.15.0rc2,<2.16
            ansible_runner:
              package_pip: ansible-runner
            system: |
              git-core [platform:rpm]
              python3.9-devel [platform:rpm compile]
              libcurl-devel [platform:rpm compile]
              sshpass [platform:rpm]
              rsync [platform:rpm]
              epel-release [platform:rpm]
              unzip [platform:rpm]
            galaxy: requirements.yml
            python: requirements.txt

          additional_build_files:
            - src: ${COLLECTION_FILENAME}
              dest: src
            - src: ${COLLECTION_PIP_REQUIREMENTS}
              dest: src

          additional_build_steps:
            append_base:
              - RUN \$PYCMD -m pip install -U pip
            prepend_builder:
              - COPY _build/src/requirements.txt src/requirements.txt
            append_final:
              # SymLink `python` -> `python3.9`
              - RUN alternatives --install /usr/bin/python python /usr/bin/python3.9 39
          EOF
          echo "::group::execution-environment.yml"
          cat execution-environment.yml
          echo "::endgroup::"

          # Collection Requirements
          cat > requirements.yml <<EOF
          ---
          collections:
            - name: src/${COLLECTION_FILENAME}
              type: file
            - name: awx.awx
            - community.general
          EOF
          echo "::group::requirements.yml"
          cat requirements.yml
          echo "::endgroup::"

          # Python Requirements
          cat > requirements.txt <<EOF
          -r src/requirements.txt
          jmespath
          EOF
          echo "::group::requirements.txt"
          cat requirements.txt
          echo "::endgroup::"
        working-directory: .

      - name: create execution env context
        run: |
          poetry run -C ansible_collections/${{ env.NAMESPACE }}/${{ env.COLLECTION_NAME }} ansible-builder create -v 3 --output-filename Dockerfile
          ls -l ./context/
          ls -l ./context/_build/src/
          cat ./context/_build/src/requirements.txt
          cat ./context/Dockerfile
        working-directory: .

      - name: login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: build and publish
        uses: docker/build-push-action@v5
        with:
          context: "./context/"
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          provenance: false     # disabled to keep number of images low for development branches

  build_release_ee:
    name: Release Ansible EE
    runs-on: ubuntu-latest
    if: inputs.release
    # if: github.event_name == 'release' && github.event.action == 'published'
    # NOTE what if we make a release from develop branch? dont worry it would make both develop and alpha images I suppose..:)

    permissions:
      contents: read
      packages: write

    defaults:
      run:
        working-directory: ansible_collections/${{ env.NAMESPACE }}/${{ env.COLLECTION_NAME }}

    steps:

      # - name: Proceed if release job from CI workflow succeeded
      #   run: |
      #     curl -L \
      #       -H "Accept: application/vnd.github+json" \
      #       -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
      #       -H "X-GitHub-Api-Version: 2022-11-28" \
      #       ${{ github.event.workflow_run.jobs_url }} > jobs.json
      #     conclusion=$(jq < jobs.json --raw-output '.jobs[] | select( .name == "release" ) | .conclusion')
      #     echo ${conclusion}
      #     [[ ${conclusion} == "success" ]]
      #   working-directory: .

      - name: check out code
        uses: actions/checkout@v4
        with:
          path: ./ansible_collections/${{ env.NAMESPACE }}/${{ env.COLLECTION_NAME }}

      - name: discover Python version
        id: pyversion
        shell: bash
        run: |
          PYVER=$(grep '^[Pp]ython ' pyproject.toml | sed -E 's/python += +\"\^?([0-9]\.[0-9]+)(\.[0-9]+)?\"/\1/; /python/q1')
          echo "pyversion=$PYVER" >> $GITHUB_OUTPUT
        # uses: PaloAltoNetworks/pan-os-upgrade-assurance/.github/actions/discover_python_version@v0.3.1
        # working-directory doesn't work with uses, until you get a `with path` similar to checkout this is going to be inline

      - name: install Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ steps.pyversion.outputs.pyversion }}
          cache: pip

      - name: install Poetry
        uses: Gr1N/setup-poetry@v8

      - name: prep Poetry venv
        run: |
          poetry env use ${{ steps.pyversion.outputs.pyversion }}
          poetry lock
          poetry install --with ansible-ee --without dev --no-root

      - name: set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: get version for release image
        id: tag
        run: echo "version_tag=$(poetry version -s)" >> $GITHUB_OUTPUT

      # TODO latest should only be tagged for release versions
      - name: determine docker tags and labels for release image
        id: meta
        uses: docker/metadata-action@v5
        with:
          context: workflow # git - this ensures to reference the current git context instead of workflow context (context info ref/sha)
          images: ghcr.io/alperenkose/pan-os-ansible # TODO ghcr.io/paloaltonetworks/pan-os-ansible
          tags: |
            type=semver,pattern=v{{version}},value=${{ steps.tag.outputs.version_tag }}
            type=semver,pattern=v{{major}}.{{minor}},value=${{ steps.tag.outputs.version_tag }}
            type=semver,pattern=v{{major}},value=${{ steps.tag.outputs.version_tag }}

      - name: Create files for building execution environment
        run: |
          COLLECTION_PIP_REQUIREMENTS="ansible_collections/${{ env.NAMESPACE }}/${{ env.COLLECTION_NAME }}/requirements.txt"

          # EE config
          cat > execution-environment.yml <<EOF
          ---
          version: 3

          images:
            base_image:
              name: quay.io/centos/centos:stream9

          dependencies:
            python_interpreter:
              package_system: python3.9
              python_path: /usr/bin/python3.9
            ansible_core:
              package_pip: ansible-core>=2.15.0rc2,<2.16
            ansible_runner:
              package_pip: ansible-runner
            system: |
              git-core [platform:rpm]
              python3.9-devel [platform:rpm compile]
              libcurl-devel [platform:rpm compile]
              sshpass [platform:rpm]
              rsync [platform:rpm]
              epel-release [platform:rpm]
              unzip [platform:rpm]
            galaxy: requirements.yml
            python: requirements.txt

          additional_build_files:
            - src: ${COLLECTION_PIP_REQUIREMENTS}
              dest: src

          additional_build_steps:
            append_base:
              - RUN \$PYCMD -m pip install -U pip
            prepend_builder:
              - COPY _build/src/requirements.txt src/requirements.txt
            append_final:
              # SymLink `python` -> `python3.9`
              - RUN alternatives --install /usr/bin/python python /usr/bin/python3.9 39
          EOF
          echo "::group::execution-environment.yml"
          cat execution-environment.yml
          echo "::endgroup::"

          # Collection Requirements
          cat > requirements.yml <<EOF
          ---
          collections:
            - name: paloaltonetworks.panos
              version: ${{steps.tag.outputs.version_tag}}
            - name: awx.awx
            - community.general
          EOF
          echo "::group::requirements.yml"
          cat requirements.yml
          echo "::endgroup::"

          # Python Requirements
          cat > requirements.txt <<EOF
          -r src/requirements.txt
          jmespath
          EOF
          echo "::group::requirements.txt"
          cat requirements.txt
          echo "::endgroup::"
        working-directory: .

      - name: create execution env context
        run: |
          poetry run -C ansible_collections/${{ env.NAMESPACE }}/${{ env.COLLECTION_NAME }} ansible-builder create -v 3 --output-filename Dockerfile
          ls -l ./context/
          ls -l ./context/_build/src/
          cat ./context/_build/src/requirements.txt
          cat ./context/Dockerfile
        working-directory: .

      - name: login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: build and publish
        uses: docker/build-push-action@v5
        with:
          context: "./context/"
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
